# [Задача №1](https://github.com/AllIWantIsNotAvailable/GeekBrains_IntroductionToJava/blob/main/seminars/Sem04_Data_Storage_and_Processing_Part_1/HomeWork/src/Task01.java):
> ## Комментарии к задаче:
> Как и было отмечено в разборе самостоятельной работы на семинаре:
> - создаем новый экземпляр ArrayList<>;
> - заполняем новый экземпляр элементами исходного экземпляра в обратном порядке;
> - возвращаем "перевернутую" версию исходного ArrayList<>.
>

# [Задача №2](https://github.com/AllIWantIsNotAvailable/GeekBrains_IntroductionToJava/blob/main/seminars/Sem04_Data_Storage_and_Processing_Part_1/HomeWork/src/Task02.java):
> ## Комментарии к задаче:
> - [Ссылка на код класса](https://github.com/AllIWantIsNotAvailable/GeekBrains_IntroductionToJava/blob/main/seminars/Sem04_Data_Storage_and_Processing_Part_1/HomeWork/src/Classes/OwnQueue.java);
> - реализация весьма простая, используем методы ArrayList<> обернутые в требуемые по условию идентификаторы;
> - бесконечным циклом для взаимодействия с собственным "интерфейсом" было решено пренебречь.
>

# [Задача №3](https://github.com/AllIWantIsNotAvailable/GeekBrains_IntroductionToJava/blob/main/seminars/Sem04_Data_Storage_and_Processing_Part_1/HomeWork/src/Task03.java):
> ## Комментарии к задаче:
> - инициализируем переменную типа ListIterator<>;
> - инициализируем временную переменную "инкремент", для накопления суммы значений исходного LinkedList<>.
>

# [Задача со звездочкой №4](https://github.com/AllIWantIsNotAvailable/GeekBrains_IntroductionToJava/blob/main/seminars/Sem04_Data_Storage_and_Processing_Part_1/HomeWork/src/TaskStar04.java):
> ## Комментарии к задаче:
> - [Ссылка на код класса](https://github.com/AllIWantIsNotAvailable/GeekBrains_IntroductionToJava/blob/main/seminars/Sem04_Data_Storage_and_Processing_Part_1/HomeWork/src/Classes/StarQueue.java);
> - реализация массивом немного сложнее, написана по аналогии с семинарской задачей;
> - созданы 2 дополнительные приватные переменные, которые хранят индексы "первого" и "последнего" элемента очереди;
> - реализовано расширение массива, в случае недостатка длины массива для записи очередного элемента;
> - реализован дополнительный метод `size()`, возвращает длину очереди;
> - реализован механизм сжатия массива, если длина очереди составляет половину (или меньше половины) длины массива;
> - бесконечным циклом для взаимодействия с собственным "интерфейсом" было решено пренебречь. 
> 
